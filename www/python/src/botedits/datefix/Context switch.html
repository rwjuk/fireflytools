
    <table class="diff" id="difflib_chg_to17__top"
           cellspacing="0" cellpadding="0" rules="groups" >
        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
        
        <tbody>
            <tr><td class="diff_next" id="difflib_chg_to17__0"></td><td class="diff_header" id="from17_37">37</td><td >However, certain special instructions require [[System call|system calls]] that require context switch to wait/sleep processes.  A system call handler is used for context switch to [[Kernel (operating system)|kernel]] mode. A display(data x) function may require data x from the Disk and a device driver in kernel mode, hence the display() function goes to sleep and waits on the READ operation to get the value of x from the [[Disk partitioning|disk]], causing the program to wait and a wait for [[Function (mathematics)|function]] call to the released setting the current statement to go to sleep and wait for the syscall to wake it up. To maintain [[Concurrency control|concurrency]] however the program needs to re-execute the new value and the sleeping process together again.</td><td class="diff_next"></td><td class="diff_header" id="to17_37">37</td><td >However, certain special instructions require [[System call|system calls]] that require context switch to wait/sleep processes.  A system call handler is used for context switch to [[Kernel (operating system)|kernel]] mode. A display(data x) function may require data x from the Disk and a device driver in kernel mode, hence the display() function goes to sleep and waits on the READ operation to get the value of x from the [[Disk partitioning|disk]], causing the program to wait and a wait for [[Function (mathematics)|function]] call to the released setting the current statement to go to sleep and wait for the syscall to wake it up. To maintain [[Concurrency control|concurrency]] however the program needs to re-execute the new value and the sleeping process together again.</td></tr>
            <tr><td class="diff_next"></td><td class="diff_header" id="from17_38">38</td><td ></td><td class="diff_next"></td><td class="diff_header" id="to17_38">38</td><td ></td></tr>
            <tr><td class="diff_next"></td><td class="diff_header" id="from17_39">39</td><td >== {{Anchor|LATENCY}}Performance ==</td><td class="diff_next"></td><td class="diff_header" id="to17_39">39</td><td >== {{Anchor|LATENCY}}Performance ==</td></tr>
            <tr><td class="diff_next"><a href="#difflib_chg_to17__top">t</a></td><td class="diff_header" id="from17_40">40</td><td >Context switching itself has a cost in performance, due to running the [[scheduling (computing)|task scheduler]], TLB flushes, and indirectly due to sharing the [[CPU cache]] between multiple tasks.&lt;ref&gt;{{cite journal |author1=Chuanpeng Li |author2=Chen Ding |author3=Kai Shen |title=Quantifying The Cost of Context Switch |url=https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf }}&lt;/ref&gt; Switching between threads of a single process can be faster than between two separate processes, because threads share the same [[virtual memory]] maps, so a TLB flush is not necessary.&lt;ref&gt;{{cite news |author=Ulrich Drepper |date=<span class="diff_chg">{{date|</span>2014<span class="diff_sub">-10-09}}</span> |title=Memory part 3: Virtual Memory |publisher=[[LWN.net]] |url=https://lwn.net/Articles/253361/ }}&lt;/ref&gt;</td><td class="diff_next"><a href="#difflib_chg_to17__top">t</a></td><td class="diff_header" id="to17_40">40</td><td >Context switching itself has a cost in performance, due to running the [[scheduling (computing)|task scheduler]], TLB flushes, and indirectly due to sharing the [[CPU cache]] between multiple tasks.&lt;ref&gt;{{cite journal |author1=Chuanpeng Li |author2=Chen Ding |author3=Kai Shen |title=Quantifying The Cost of Context Switch |url=https://www.usenix.org/legacy/events/expcs07/papers/2-li.pdf }}&lt;/ref&gt; Switching between threads of a single process can be faster than between two separate processes, because threads share the same [[virtual memory]] maps, so a TLB flush is not necessary.&lt;ref&gt;{{cite news |author=Ulrich Drepper |date=<span class="diff_chg">9 October </span>2014 |title=Memory part 3: Virtual Memory |publisher=[[LWN.net]] |url=https://lwn.net/Articles/253361/ }}&lt;/ref&gt;</td></tr>
            <tr><td class="diff_next"></td><td class="diff_header" id="from17_41">41</td><td ></td><td class="diff_next"></td><td class="diff_header" id="to17_41">41</td><td ></td></tr>
            <tr><td class="diff_next"></td><td class="diff_header" id="from17_42">42</td><td >=== Hardware vs. software ===</td><td class="diff_next"></td><td class="diff_header" id="to17_42">42</td><td >=== Hardware vs. software ===</td></tr>
            <tr><td class="diff_next"></td><td class="diff_header" id="from17_43">43</td><td >Context switching can be performed primarily by software or hardware. Some processors, like the [[Intel 80386]] and its successors,&lt;ref&gt;{{cite web |url=http://www.linfo.org/context_switch.html |title=Context Switch definition |publisher=Linfo.org |access-date=2013-09-08 |archive-url=https://web.archive.org/web/20100218115342/http://www.linfo.org/context_switch.html |archive-date=2010-02-18 |url-status=dead }}&lt;/ref&gt; have hardware support for context switches, by making use of a special data segment designated the [[task state segment]] (TSS).  A task switch can be explicitly triggered with a CALL or JMP instruction targeted at a TSS descriptor in the [[global descriptor table]].  It can occur implicitly when an interrupt or exception is triggered if there's a [[task gate]] in the [[interrupt descriptor table]] (IDT).  When a task switch occurs the CPU can automatically load the new state from the TSS.</td><td class="diff_next"></td><td class="diff_header" id="to17_43">43</td><td >Context switching can be performed primarily by software or hardware. Some processors, like the [[Intel 80386]] and its successors,&lt;ref&gt;{{cite web |url=http://www.linfo.org/context_switch.html |title=Context Switch definition |publisher=Linfo.org |access-date=2013-09-08 |archive-url=https://web.archive.org/web/20100218115342/http://www.linfo.org/context_switch.html |archive-date=2010-02-18 |url-status=dead }}&lt;/ref&gt; have hardware support for context switches, by making use of a special data segment designated the [[task state segment]] (TSS).  A task switch can be explicitly triggered with a CALL or JMP instruction targeted at a TSS descriptor in the [[global descriptor table]].  It can occur implicitly when an interrupt or exception is triggered if there's a [[task gate]] in the [[interrupt descriptor table]] (IDT).  When a task switch occurs the CPU can automatically load the new state from the TSS.</td></tr>
        </tbody>
    </table>